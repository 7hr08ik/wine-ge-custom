From c7d140d34aa6f40a92f95fd8698501d3283c9296 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 29 Jun 2020 15:46:10 +0200
Subject: [PATCH] winhttp: Reimplement the task queue using thread pool work
 objects.

Simplifies cleanup.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 336 ++++++++++++++++-----------------
 dlls/winhttp/session.c         |  12 +-
 dlls/winhttp/winhttp_private.h |  31 +--
 3 files changed, 169 insertions(+), 210 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index c15be385925..bc3d365f7cd 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -122,92 +122,34 @@ static const WCHAR *attribute_table[] =
     NULL                            /* WINHTTP_QUERY_PASSPORT_CONFIG            = 78 */
 };
 
-static struct task_header *dequeue_task( struct queue *queue )
+static DWORD start_queue( struct queue *queue )
 {
-    struct task_header *task;
+    if (queue->pool) return ERROR_SUCCESS;
 
-    EnterCriticalSection( &queue->cs );
-    TRACE("%u tasks queued in %p\n", list_count(&queue->tasks), queue);
-    task = LIST_ENTRY( list_head( &queue->tasks ), struct task_header, entry );
-    if (task) list_remove( &task->entry );
-    LeaveCriticalSection( &queue->cs );
+    if (!(queue->pool = CreateThreadpool( NULL ))) return GetLastError();
+    SetThreadpoolThreadMinimum( queue->pool, 1 );
+    SetThreadpoolThreadMaximum( queue->pool, 1 );
 
-    TRACE("returning task %p\n", task);
-    return task;
-}
-
-static void CALLBACK run_queue( TP_CALLBACK_INSTANCE *instance, void *ctx )
-{
-    struct queue *queue = ctx;
-    HANDLE handles[] = { queue->wait, queue->cancel };
-
-    for (;;)
-    {
-        DWORD err = WaitForMultipleObjects( 2, handles, FALSE, INFINITE );
-        switch (err)
-        {
-        case WAIT_OBJECT_0:
-        {
-            struct task_header *task;
-            while ((task = dequeue_task( queue )))
-            {
-                task->proc( task );
-                release_object( task->object );
-                heap_free( task );
-            }
-            break;
-        }
-        case WAIT_OBJECT_0 + 1:
-            TRACE("exiting\n");
-            CloseHandle( queue->wait );
-            CloseHandle( queue->cancel );
-            queue->object->vtbl->destroy( queue->object );
-            return;
-
-        default:
-            ERR("wait failed %u (%u)\n", err, GetLastError());
-            break;
-        }
-    }
-}
+    memset( &queue->env, 0, sizeof(queue->env) );
+    queue->env.Version = 1;
+    queue->env.Pool = queue->pool;
 
-static DWORD start_queue( struct object_header *object, struct queue *queue )
-{
-    DWORD ret = ERROR_OUTOFMEMORY;
-
-    if (queue->wait) return ERROR_SUCCESS;
-
-    queue->object = object;
-    list_init( &queue->tasks );
-    if (!(queue->wait = CreateEventW( NULL, FALSE, FALSE, NULL ))) goto error;
-    if (!(queue->cancel = CreateEventW( NULL, FALSE, FALSE, NULL ))) goto error;
-    if (!TrySubmitThreadpoolCallback( run_queue, queue, NULL )) ret = GetLastError();
-    else
-    {
-        queue->proc_running = TRUE;
-        TRACE("started %p\n", queue);
-        return ERROR_SUCCESS;
-    }
-
-error:
-    CloseHandle( queue->wait );
-    queue->wait = NULL;
-    CloseHandle( queue->cancel );
-    queue->cancel = NULL;
-    return ret;
+    TRACE("started %p\n", queue);
+    return ERROR_SUCCESS;
 }
 
-static DWORD queue_task( struct object_header *object, struct queue *queue, struct task_header *task )
+static DWORD queue_task( struct queue *queue, PTP_WORK_CALLBACK task, void *ctx )
 {
+    TP_WORK *work;
     DWORD ret;
-    if ((ret = start_queue( object, queue ))) return ret;
 
-    EnterCriticalSection( &queue->cs );
-    TRACE("queueing task %p in %p\n", task, queue);
-    list_add_tail( &queue->tasks, &task->entry );
-    LeaveCriticalSection( &queue->cs );
+    if ((ret = start_queue( queue ))) return ret;
+
+    if (!(work = CreateThreadpoolWork( task, ctx, &queue->env ))) return GetLastError();
+    TRACE("queueing %p in %p\n", work, queue);
+    SubmitThreadpoolWork( work );
+    CloseThreadpoolWork( work );
 
-    SetEvent( queue->wait );
     return ERROR_SUCCESS;
 }
 
@@ -2216,13 +2158,16 @@ static DWORD send_request( struct request *request, const WCHAR *headers, DWORD
     return ret;
 }
 
-static void task_send_request( struct task_header *task )
+static void CALLBACK task_send_request( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    struct send_request *s = (struct send_request *)task;
+    struct send_request *s = ctx;
+
+    TRACE("running %p\n", work);
+    send_request( s->request, s->headers, s->headers_len, s->optional, s->optional_len, s->total_len, s->context, TRUE );
 
-    send_request( request, s->headers, s->headers_len, s->optional, s->optional_len, s->total_len, s->context, TRUE );
+    release_object( &s->request->hdr );
     heap_free( s->headers );
+    heap_free( s );
 }
 
 /***********************************************************************
@@ -2256,8 +2201,7 @@ BOOL WINAPI WinHttpSendRequest( HINTERNET hrequest, LPCWSTR headers, DWORD heade
         struct send_request *s;
 
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
-        s->hdr.object   = &request->hdr;
-        s->hdr.proc     = task_send_request;
+        s->request      = request;
         s->headers      = strdupW( headers );
         s->headers_len  = headers_len;
         s->optional     = optional;
@@ -2266,7 +2210,12 @@ BOOL WINAPI WinHttpSendRequest( HINTERNET hrequest, LPCWSTR headers, DWORD heade
         s->context      = context;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)s );
+        if ((ret = queue_task( &request->queue, task_send_request, s )))
+        {
+            release_object( &request->hdr );
+            heap_free( s->headers );
+            heap_free( s );
+        }
     }
     else ret = send_request( request, headers, headers_len, optional, optional_len, total_len, context, FALSE );
 
@@ -2797,10 +2746,15 @@ static DWORD receive_response( struct request *request, BOOL async )
     return ret;
 }
 
-static void task_receive_response( struct task_header *task )
+static void CALLBACK task_receive_response( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    receive_response( request, TRUE );
+    struct receive_response *r = ctx;
+
+    TRACE("running %p\n", work);
+    receive_response( r->request, TRUE );
+
+    release_object( &r->request->hdr );
+    heap_free( r );
 }
 
 /***********************************************************************
@@ -2830,11 +2784,14 @@ BOOL WINAPI WinHttpReceiveResponse( HINTERNET hrequest, LPVOID reserved )
         struct receive_response *r;
 
         if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
-        r->hdr.object = &request->hdr;
-        r->hdr.proc   = task_receive_response;
+        r->request = request;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)r );
+        if ((ret = queue_task( &request->queue, task_receive_response, r )))
+        {
+            release_object( &request->hdr );
+            heap_free( r );
+        }
     }
     else ret = receive_response( request, FALSE );
 
@@ -2876,12 +2833,15 @@ static DWORD query_data_available( struct request *request, DWORD *available, BO
     return ret;
 }
 
-static void task_query_data_available( struct task_header *task )
+static void CALLBACK task_query_data_available( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    struct query_data *q = (struct query_data *)task;
+    struct query_data *q = ctx;
 
-    query_data_available( request, q->available, TRUE );
+    TRACE("running %p\n", work);
+    query_data_available( q->request, q->available, TRUE );
+
+    release_object( &q->request->hdr );
+    heap_free( q );
 }
 
 /***********************************************************************
@@ -2911,12 +2871,15 @@ BOOL WINAPI WinHttpQueryDataAvailable( HINTERNET hrequest, LPDWORD available )
         struct query_data *q;
 
         if (!(q = heap_alloc( sizeof(*q) ))) return FALSE;
-        q->hdr.object = &request->hdr;
-        q->hdr.proc   = task_query_data_available;
-        q->available  = available;
+        q->request   = request;
+        q->available = available;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)q );
+        if ((ret = queue_task( &request->queue, task_query_data_available, q )))
+        {
+            release_object( &request->hdr );
+            heap_free( q );
+        }
     }
     else ret = query_data_available( request, available, FALSE );
 
@@ -2925,12 +2888,15 @@ BOOL WINAPI WinHttpQueryDataAvailable( HINTERNET hrequest, LPDWORD available )
     return !ret;
 }
 
-static void task_read_data( struct task_header *task )
+static void CALLBACK task_read_data( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    struct read_data *r = (struct read_data *)task;
+    struct read_data *r = ctx;
+
+    TRACE("running %p\n", work);
+    read_data( r->request, r->buffer, r->to_read, r->read, TRUE );
 
-    read_data( request, r->buffer, r->to_read, r->read, TRUE );
+    release_object( &r->request->hdr );
+    heap_free( r );
 }
 
 /***********************************************************************
@@ -2960,14 +2926,17 @@ BOOL WINAPI WinHttpReadData( HINTERNET hrequest, LPVOID buffer, DWORD to_read, L
         struct read_data *r;
 
         if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
-        r->hdr.object = &request->hdr;
-        r->hdr.proc   = task_read_data;
-        r->buffer     = buffer;
-        r->to_read    = to_read;
-        r->read       = read;
+        r->request = request;
+        r->buffer  = buffer;
+        r->to_read = to_read;
+        r->read    = read;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)r );
+        if ((ret = queue_task( &request->queue, task_read_data, r )))
+        {
+            release_object( &request->hdr );
+            heap_free( r );
+        }
     }
     else ret = read_data( request, buffer, to_read, read, FALSE );
 
@@ -2998,12 +2967,15 @@ static DWORD write_data( struct request *request, const void *buffer, DWORD to_w
     return ret;
 }
 
-static void task_write_data( struct task_header *task )
+static void CALLBACK task_write_data( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    struct write_data *w = (struct write_data *)task;
+    struct write_data *w = ctx;
 
-    write_data( request, w->buffer, w->to_write, w->written, TRUE );
+    TRACE("running %p\n", work);
+    write_data( w->request, w->buffer, w->to_write, w->written, TRUE );
+
+    release_object( &w->request->hdr );
+    heap_free( w );
 }
 
 /***********************************************************************
@@ -3033,14 +3005,17 @@ BOOL WINAPI WinHttpWriteData( HINTERNET hrequest, LPCVOID buffer, DWORD to_write
         struct write_data *w;
 
         if (!(w = heap_alloc( sizeof(*w) ))) return FALSE;
-        w->hdr.object = &request->hdr;
-        w->hdr.proc   = task_write_data;
-        w->buffer     = buffer;
-        w->to_write   = to_write;
-        w->written    = written;
+        w->request  = request;
+        w->buffer   = buffer;
+        w->to_write = to_write;
+        w->written  = written;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)w );
+        if ((ret = queue_task( &request->queue, task_write_data, w )))
+        {
+            release_object( &request->hdr );
+            heap_free( w );
+        }
     }
     else ret = write_data( request, buffer, to_write, written, FALSE );
 
@@ -3062,25 +3037,10 @@ static void socket_destroy( struct object_header *hdr )
 
     TRACE("%p\n", socket);
 
-    if (socket->send_q.proc_running)
-    {
-        socket->send_q.proc_running = FALSE;
-        SetEvent( socket->send_q.cancel );
-        return;
-    }
-    if (socket->recv_q.proc_running)
-    {
-        socket->recv_q.proc_running = FALSE;
-        SetEvent( socket->recv_q.cancel );
-        return;
-    }
-    release_object( &socket->request->hdr );
-
-    socket->send_q.cs.DebugInfo->Spare[0] = 0;
-    DeleteCriticalSection( &socket->send_q.cs );
+    if (socket->send_q.pool) CloseThreadpool( socket->send_q.pool );
+    if (socket->recv_q.pool) CloseThreadpool( socket->recv_q.pool );
 
-    socket->recv_q.cs.DebugInfo->Spare[0] = 0;
-    DeleteCriticalSection( &socket->recv_q.cs );
+    release_object( &socket->request->hdr );
     heap_free( socket );
 }
 
@@ -3128,10 +3088,6 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     socket->hdr.callback = request->hdr.callback;
     socket->hdr.notify_mask = request->hdr.notify_mask;
     socket->hdr.context = context;
-    InitializeCriticalSection( &socket->send_q.cs );
-    socket->send_q.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": socket.send_q.cs");
-    InitializeCriticalSection( &socket->recv_q.cs );
-    socket->recv_q.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": socket.recv_q.cs");
 
     addref_object( &request->hdr );
     socket->request = request;
@@ -3252,12 +3208,15 @@ static DWORD socket_send( struct socket *socket, WINHTTP_WEB_SOCKET_BUFFER_TYPE
     return ret;
 }
 
-static void task_socket_send( struct task_header *task )
+static void CALLBACK task_socket_send( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct socket *socket = (struct socket *)task->object;
-    struct socket_send *s = (struct socket_send *)task;
+    struct socket_send *s = ctx;
 
-    socket_send( socket, s->type, s->buf, s->len, TRUE );
+    TRACE("running %p\n", work);
+    socket_send( s->socket, s->type, s->buf, s->len, TRUE );
+
+    release_object( &s->socket->hdr );
+    heap_free( s );
 }
 
 DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, void *buf, DWORD len )
@@ -3291,14 +3250,17 @@ DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_
         struct socket_send *s;
 
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
-        s->hdr.object = &socket->hdr;
-        s->hdr.proc   = task_socket_send;
-        s->type       = type;
-        s->buf        = buf;
-        s->len        = len;
+        s->socket = socket;
+        s->type   = type;
+        s->buf    = buf;
+        s->len    = len;
 
         addref_object( &socket->hdr );
-        ret = queue_task( &socket->hdr, &socket->send_q, (struct task_header *)s );
+        if ((ret = queue_task( &socket->send_q, task_socket_send, s )))
+        {
+            release_object( &socket->hdr );
+            heap_free( s );
+        }
     }
     else ret = socket_send( socket, type, buf, len, FALSE );
 
@@ -3404,12 +3366,15 @@ static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD
     return ret;
 }
 
-static void task_socket_receive( struct task_header *task )
+static void CALLBACK task_socket_receive( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct socket *socket = (struct socket *)task->object;
-    struct socket_receive *r = (struct socket_receive *)task;
+    struct socket_receive *r = ctx;
+
+    TRACE("running %p\n", work);
+    socket_receive( r->socket, r->buf, r->len, NULL, NULL, TRUE );
 
-    socket_receive( socket, r->buf, r->len, NULL, NULL, TRUE );
+    release_object( &r->socket->hdr );
+    heap_free( r );
 }
 
 DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *ret_len,
@@ -3439,13 +3404,16 @@ DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, D
         struct socket_receive *r;
 
         if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
-        r->hdr.object = &socket->hdr;
-        r->hdr.proc   = task_socket_receive;
-        r->buf        = buf;
-        r->len        = len;
+        r->socket = socket;
+        r->buf    = buf;
+        r->len    = len;
 
         addref_object( &socket->hdr );
-        ret = queue_task( &socket->hdr, &socket->recv_q, (struct task_header *)r );
+        if ((ret = queue_task( &socket->recv_q, task_socket_receive, r )))
+        {
+            release_object( &socket->hdr );
+            heap_free( r );
+        }
     }
     else ret = socket_receive( socket, buf, len, ret_len, ret_type, FALSE );
 
@@ -3477,12 +3445,15 @@ static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *
     return ret;
 }
 
-static void task_socket_shutdown( struct task_header *task )
+static void CALLBACK task_socket_shutdown( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct socket *socket = (struct socket *)task->object;
-    struct socket_shutdown *s = (struct socket_shutdown *)task;
+    struct socket_shutdown *s = ctx;
 
-    socket_shutdown( socket, s->status, s->reason, s->len, TRUE );
+    socket_shutdown( s->socket, s->status, s->reason, s->len, TRUE );
+
+    TRACE("running %p\n", work);
+    release_object( &s->socket->hdr );
+    heap_free( s );
 }
 
 DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
@@ -3511,14 +3482,17 @@ DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *r
         struct socket_shutdown *s;
 
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
-        s->hdr.object = &socket->hdr;
-        s->hdr.proc   = task_socket_shutdown;
-        s->status     = status;
-        s->reason     = reason;
-        s->len        = len;
+        s->socket = socket;
+        s->status = status;
+        s->reason = reason;
+        s->len    = len;
 
         addref_object( &socket->hdr );
-        ret = queue_task( &socket->hdr, &socket->send_q, (struct task_header *)s );
+        if ((ret = queue_task( &socket->send_q, task_socket_shutdown, s )))
+        {
+            release_object( &socket->hdr );
+            heap_free( s );
+        }
     }
     else ret = socket_shutdown( socket, status, reason, len, FALSE );
 
@@ -3577,12 +3551,15 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
     return ret;
 }
 
-static void task_socket_close( struct task_header *task )
+static void CALLBACK task_socket_close( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct socket *socket = (struct socket *)task->object;
-    struct socket_shutdown *s = (struct socket_shutdown *)task;
+    struct socket_shutdown *s = ctx;
+
+    socket_close( s->socket, s->status, s->reason, s->len, TRUE );
 
-    socket_close( socket, s->status, s->reason, s->len, TRUE );
+    TRACE("running %p\n", work);
+    release_object( &s->socket->hdr );
+    heap_free( s );
 }
 
 DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
@@ -3611,14 +3588,17 @@ DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reas
         struct socket_shutdown *s;
 
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
-        s->hdr.object = &socket->hdr;
-        s->hdr.proc   = task_socket_close;
-        s->status     = status;
-        s->reason     = reason;
-        s->len        = len;
+        s->socket = socket;
+        s->status = status;
+        s->reason = reason;
+        s->len    = len;
 
         addref_object( &socket->hdr );
-        ret = queue_task( &socket->hdr, &socket->recv_q, (struct task_header *)s );
+        if ((ret = queue_task( &socket->recv_q, task_socket_close, s )))
+        {
+            release_object( &socket->hdr );
+            heap_free( s );
+        }
     }
     else ret = socket_close( socket, status, reason, len, FALSE );
 
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index 228eb646ae0..f3ab8c9b959 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -578,13 +578,7 @@ static void request_destroy( struct object_header *hdr )
 
     TRACE("%p\n", request);
 
-    if (request->queue.proc_running)
-    {
-        /* Signal to the task proc to quit. It will call this again when it does. */
-        request->queue.proc_running = FALSE;
-        SetEvent( request->queue.cancel );
-        return;
-    }
+    if (request->queue.pool) CloseThreadpool( request->queue.pool );
     release_object( &request->connect->hdr );
 
     if (request->cred_handle_initialized) FreeCredentialsHandle( &request->cred_handle );
@@ -614,8 +608,6 @@ static void request_destroy( struct object_header *hdr )
         }
     }
 
-    request->queue.cs.DebugInfo->Spare[0] = 0;
-    DeleteCriticalSection( &request->queue.cs );
     heap_free( request );
 }
 
@@ -1120,8 +1112,6 @@ HINTERNET WINAPI WinHttpOpenRequest( HINTERNET hconnect, LPCWSTR verb, LPCWSTR o
     request->hdr.notify_mask = connect->hdr.notify_mask;
     request->hdr.context = connect->hdr.context;
     request->hdr.redirect_policy = connect->hdr.redirect_policy;
-    InitializeCriticalSection( &request->queue.cs );
-    request->queue.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": request.queue.cs");
 
     addref_object( &connect->hdr );
     request->connect = connect;
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 4a943750061..ac7e9ff09b5 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -157,12 +157,8 @@ struct authinfo
 
 struct queue
 {
-    struct object_header *object;
-    CRITICAL_SECTION cs;
-    BOOL proc_running;
-    HANDLE wait;
-    HANDLE cancel;
-    struct list tasks;
+    TP_POOL *pool;
+    TP_CALLBACK_ENVIRON env;
 };
 
 enum request_flags
@@ -252,16 +248,9 @@ struct socket
     DWORD reason_len;
 };
 
-struct task_header
-{
-    struct list entry;
-    struct object_header *object;
-    void (*proc)( struct task_header * );
-};
-
 struct send_request
 {
-    struct task_header hdr;
+    struct request *request;
     WCHAR *headers;
     DWORD headers_len;
     void *optional;
@@ -272,18 +261,18 @@ struct send_request
 
 struct receive_response
 {
-    struct task_header hdr;
+    struct request *request;
 };
 
 struct query_data
 {
-    struct task_header hdr;
+    struct request *request;
     DWORD *available;
 };
 
 struct read_data
 {
-    struct task_header hdr;
+    struct request *request;
     void *buffer;
     DWORD to_read;
     DWORD *read;
@@ -291,7 +280,7 @@ struct read_data
 
 struct write_data
 {
-    struct task_header hdr;
+    struct request *request;
     const void *buffer;
     DWORD to_write;
     DWORD *written;
@@ -299,7 +288,7 @@ struct write_data
 
 struct socket_send
 {
-    struct task_header hdr;
+    struct socket *socket;
     WINHTTP_WEB_SOCKET_BUFFER_TYPE type;
     const void *buf;
     DWORD len;
@@ -307,14 +296,14 @@ struct socket_send
 
 struct socket_receive
 {
-    struct task_header hdr;
+    struct socket *socket;
     void *buf;
     DWORD len;
 };
 
 struct socket_shutdown
 {
-    struct task_header hdr;
+    struct socket *socket;
     USHORT status;
     const void *reason;
     DWORD len;
From 7b7fdb8585b78fcb9ead0b65472196c0fffe23c8 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 29 Jun 2020 15:46:11 +0200
Subject: [PATCH] winhttp: Copy the reason buffer.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 8 ++++----
 dlls/winhttp/tests/winhttp.c   | 6 ++++++
 dlls/winhttp/winhttp_private.h | 4 ++--
 3 files changed, 12 insertions(+), 6 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index bc3d365f7cd..06588d6f606 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3463,7 +3463,7 @@ DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *r
 
     TRACE("%p, %u, %p, %u\n", hsocket, status, reason, len);
 
-    if (len && !reason) return ERROR_INVALID_PARAMETER;
+    if ((len && !reason) || len > sizeof(socket->reason)) return ERROR_INVALID_PARAMETER;
 
     if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
     if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
@@ -3484,7 +3484,7 @@ DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *r
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
         s->socket = socket;
         s->status = status;
-        s->reason = reason;
+        memcpy( s->reason, reason, len );
         s->len    = len;
 
         addref_object( &socket->hdr );
@@ -3569,7 +3569,7 @@ DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reas
 
     TRACE("%p, %u, %p, %u\n", hsocket, status, reason, len);
 
-    if (len && !reason) return ERROR_INVALID_PARAMETER;
+    if ((len && !reason) || len > sizeof(socket->reason)) return ERROR_INVALID_PARAMETER;
 
     if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
     if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
@@ -3590,7 +3590,7 @@ DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reas
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
         s->socket = socket;
         s->status = status;
-        s->reason = reason;
+        memcpy( s->reason, reason, len );
         s->len    = len;
 
         addref_object( &socket->hdr );
diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index 12f5136973f..84063fdc82a 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -3356,6 +3356,9 @@ static void test_websocket(int port)
     error = pWinHttpWebSocketShutdown(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, NULL, 1);
     ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
 
+    error = pWinHttpWebSocketShutdown(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, buf, sizeof(buf));
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
     error = pWinHttpWebSocketShutdown(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, (void *)"success",
                                       sizeof("success"));
     ok(!error, "got %u\n", error);
@@ -3363,6 +3366,9 @@ static void test_websocket(int port)
     error = pWinHttpWebSocketClose(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, NULL, 1);
     ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
 
+    error = pWinHttpWebSocketClose(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, buf, sizeof(buf));
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
     error = pWinHttpWebSocketClose(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, (void *)"success2",
                                    sizeof("success2"));
     ok(!error, "got %u\n", error);
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index ac7e9ff09b5..9d0b9c308ab 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -244,7 +244,7 @@ struct socket
     enum socket_opcode opcode;
     DWORD read_size;
     USHORT status;
-    char reason[128];
+    char reason[123];
     DWORD reason_len;
 };
 
@@ -305,7 +305,7 @@ struct socket_shutdown
 {
     struct socket *socket;
     USHORT status;
-    const void *reason;
+    char reason[123];
     DWORD len;
 };
 
From dffd8e86475a8fd034c3167b576551ff7fd02f5b Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 29 Jun 2020 15:46:12 +0200
Subject: [PATCH] winhttp: Add support for ping and pong messages.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 177 +++++++++++++++++++++++++++++++----------
 1 file changed, 136 insertions(+), 41 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 06588d6f606..7cb07b5c107 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3112,29 +3112,18 @@ static DWORD send_bytes( struct netconn *netconn, char *bytes, int len )
     return (count == len) ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR;
 }
 
-static enum socket_opcode map_buffer_type( WINHTTP_WEB_SOCKET_BUFFER_TYPE type )
-{
-    switch (type)
-    {
-    case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:   return SOCKET_OPCODE_TEXT;
-    case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE: return SOCKET_OPCODE_BINARY;
-    case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:          return SOCKET_OPCODE_CLOSE;
-    default:
-        FIXME("buffer type %u not supported\n", type);
-        return SOCKET_OPCODE_INVALID;
-    }
-}
-
 #define FIN_BIT (1 << 7)
 #define MASK_BIT (1 << 7)
 #define RESERVED_BIT (7 << 4)
+#define CONTROL_BIT (1 << 3)
 
-static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, USHORT status, const char *buf,
+static DWORD send_frame( struct netconn *netconn, enum socket_opcode opcode, USHORT status, const char *buf,
                          DWORD buflen, BOOL final )
 {
     DWORD i = 0, j, ret, offset = 2, len = buflen;
-    enum socket_opcode opcode = map_buffer_type( type );
-    char hdr[14], byte, *mask;
+    char hdr[14], byte, *mask = NULL;
+
+    TRACE("sending %02x frame\n", opcode);
 
     if (opcode == SOCKET_OPCODE_CLOSE) len += sizeof(status);
 
@@ -3159,9 +3148,14 @@ static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE
         hdr[9] = len & 0xff;
         offset += 8;
     }
-    mask = &hdr[offset];
-    RtlGenRandom( mask, 4 );
-    if ((ret = send_bytes( netconn, hdr, offset + 4 ))) return ret;
+
+    if ((ret = send_bytes( netconn, hdr, offset ))) return ret;
+    if (len)
+    {
+        mask = &hdr[offset];
+        RtlGenRandom( mask, 4 );
+        if ((ret = send_bytes( netconn, mask, 4 ))) return ret;
+    }
 
     if (opcode == SOCKET_OPCODE_CLOSE) /* prepend status code */
     {
@@ -3181,12 +3175,26 @@ static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE
     return ERROR_SUCCESS;
 }
 
+static enum socket_opcode map_buffer_type( WINHTTP_WEB_SOCKET_BUFFER_TYPE type )
+{
+    switch (type)
+    {
+    case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:   return SOCKET_OPCODE_TEXT;
+    case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE: return SOCKET_OPCODE_BINARY;
+    case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:          return SOCKET_OPCODE_CLOSE;
+    default:
+        FIXME("buffer type %u not supported\n", type);
+        return SOCKET_OPCODE_INVALID;
+    }
+}
+
 static DWORD socket_send( struct socket *socket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, const void *buf, DWORD len,
                           BOOL async )
 {
+    enum socket_opcode opcode = map_buffer_type( type );
     DWORD ret;
 
-    ret = send_frame( socket->request->netconn, type, 0, buf, len, TRUE );
+    ret = send_frame( socket->request->netconn, opcode, 0, buf, len, TRUE );
     if (async)
     {
         if (!ret)
@@ -3276,24 +3284,19 @@ static DWORD receive_bytes( struct netconn *netconn, char *buf, DWORD len, DWORD
     return ERROR_SUCCESS;
 }
 
-static WINHTTP_WEB_SOCKET_BUFFER_TYPE map_opcode( enum socket_opcode opcode, BOOL fragment )
+static BOOL is_supported_opcode( enum socket_opcode opcode )
 {
     switch (opcode)
     {
     case SOCKET_OPCODE_TEXT:
-        if (fragment) return WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE;
-        return WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE;
-
     case SOCKET_OPCODE_BINARY:
-        if (fragment) return WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE;
-        return WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
-
     case SOCKET_OPCODE_CLOSE:
-        return WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE;
-
+    case SOCKET_OPCODE_PING:
+    case SOCKET_OPCODE_PONG:
+        return TRUE;
     default:
-        FIXME("opcode %u not handled\n", opcode);
-        return ~0u;
+        FIXME( "opcode %02x not handled\n", opcode );
+        return FALSE;
     }
 }
 
@@ -3303,11 +3306,12 @@ static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, enum socket
     char hdr[2];
 
     if ((ret = receive_bytes( netconn, hdr, sizeof(hdr), &count ))) return ret;
-    if ((hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT) || (map_opcode( hdr[0] & 0xf, FALSE ) == ~0u))
+    if ((hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT) || !is_supported_opcode( hdr[0] & 0xf ))
     {
         return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
     }
     *opcode = hdr[0] & 0xf;
+    TRACE("received %02x frame\n", *opcode);
 
     len = hdr[1] & ~MASK_BIT;
     if (len == 126)
@@ -3328,13 +3332,109 @@ static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, enum socket
     return ERROR_SUCCESS;
 }
 
+static void CALLBACK task_socket_send_pong( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
+{
+    struct socket_send *s = ctx;
+
+    TRACE("running %p\n", work);
+    send_frame( s->socket->request->netconn, SOCKET_OPCODE_PONG, 0, NULL, 0, TRUE );
+
+    release_object( &s->socket->hdr );
+    heap_free( s );
+}
+
+static DWORD socket_send_pong( struct socket *socket )
+{
+    if (socket->request->connect->hdr.flags & WINHTTP_FLAG_ASYNC)
+    {
+        struct socket_send *s;
+        DWORD ret;
+
+        if (!(s = heap_alloc( sizeof(*s) ))) return ERROR_OUTOFMEMORY;
+        s->socket = socket;
+
+        addref_object( &socket->hdr );
+        if ((ret = queue_task( &socket->send_q, task_socket_send_pong, s )))
+        {
+            release_object( &socket->hdr );
+            heap_free( s );
+        }
+        return ret;
+    }
+    return send_frame( socket->request->netconn, SOCKET_OPCODE_PONG, 0, NULL, 0, TRUE );
+}
+
+static DWORD socket_drain( struct socket *socket )
+{
+    struct netconn *netconn = socket->request->netconn;
+    DWORD ret, count;
+
+    while (socket->read_size)
+    {
+        char buf[1024];
+        if ((ret = receive_bytes( netconn, buf, min(socket->read_size, sizeof(buf)), &count ))) return ret;
+        socket->read_size -= count;
+    }
+    return ERROR_SUCCESS;
+}
+
+static DWORD handle_control_frame( struct socket *socket )
+{
+    switch (socket->opcode)
+    {
+    case SOCKET_OPCODE_PING:
+        return socket_send_pong( socket );
+
+    case SOCKET_OPCODE_PONG:
+        return socket_drain( socket );
+
+    default:
+        ERR("unhandled control opcode %02x\n", socket->opcode);
+        return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+    }
+
+    return ERROR_SUCCESS;
+}
+
+static WINHTTP_WEB_SOCKET_BUFFER_TYPE map_opcode( enum socket_opcode opcode, BOOL fragment )
+{
+    switch (opcode)
+    {
+    case SOCKET_OPCODE_TEXT:
+        if (fragment) return WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE;
+        return WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE;
+
+    case SOCKET_OPCODE_BINARY:
+        if (fragment) return WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE;
+        return WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
+
+    case SOCKET_OPCODE_CLOSE:
+        return WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE;
+
+    default:
+        FIXME("opcode %02x not handled\n", opcode);
+        return ~0u;
+    }
+}
+
 static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD *ret_len,
                              WINHTTP_WEB_SOCKET_BUFFER_TYPE *ret_type, BOOL async )
 {
     struct netconn *netconn = socket->request->netconn;
     DWORD count, ret = ERROR_SUCCESS;
 
-    if (!socket->read_size) ret = receive_frame( netconn, &socket->read_size, &socket->opcode );
+    if (!socket->read_size)
+    {
+        for (;;)
+        {
+            if (!(ret = receive_frame( netconn, &socket->read_size, &socket->opcode )))
+            {
+                if (!(socket->opcode & CONTROL_BIT) || (ret = handle_control_frame( socket ))) break;
+            }
+            else if (ret == WSAETIMEDOUT) ret = socket_send_pong( socket );
+            if (ret) break;
+        }
+    }
     if (!ret) ret = receive_bytes( netconn, buf, min(len, socket->read_size), &count );
     if (!ret)
     {
@@ -3426,7 +3526,7 @@ static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *
     struct netconn *netconn = socket->request->netconn;
     DWORD ret;
 
-    if (!(ret = send_frame( netconn, WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE, status, reason, len, TRUE )))
+    if (!(ret = send_frame( netconn, SOCKET_OPCODE_CLOSE, status, reason, len, TRUE )))
     {
         socket->state = SOCKET_STATE_SHUTDOWN;
     }
@@ -3505,16 +3605,11 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
     struct netconn *netconn = socket->request->netconn;
     DWORD ret, count;
 
-    while (socket->read_size) /* drain any pending data */
-    {
-        char buf[1024];
-        if ((ret = receive_bytes( netconn, buf, min(socket->read_size, sizeof(buf)), &count ))) goto done;
-        socket->read_size -= count;
-    }
+    if ((ret = socket_drain( socket ))) goto done;
 
     if (socket->state < SOCKET_STATE_SHUTDOWN)
     {
-        if ((ret = send_frame( netconn, WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE, status, reason, len, TRUE ))) goto done;
+        if ((ret = send_frame( netconn, SOCKET_OPCODE_CLOSE, status, reason, len, TRUE ))) goto done;
         socket->state = SOCKET_STATE_SHUTDOWN;
     }
 
From 97f9dc7ff46a161468dcf7866381db23474a1031 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 29 Jun 2020 15:46:13 +0200
Subject: [PATCH] winhttp: Stop the send queue before sending the close
 message.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 14 ++++++++++++--
 dlls/winhttp/session.c         |  2 +-
 dlls/winhttp/winhttp_private.h |  1 +
 3 files changed, 14 insertions(+), 3 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 7cb07b5c107..e31803ccfed 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -138,6 +138,14 @@ static DWORD start_queue( struct queue *queue )
     return ERROR_SUCCESS;
 }
 
+void stop_queue( struct queue *queue )
+{
+    if (!queue->pool) return;
+    CloseThreadpool( queue->pool );
+    queue->pool = NULL;
+    TRACE("stopped %p\n", queue);
+}
+
 static DWORD queue_task( struct queue *queue, PTP_WORK_CALLBACK task, void *ctx )
 {
     TP_WORK *work;
@@ -3037,8 +3045,8 @@ static void socket_destroy( struct object_header *hdr )
 
     TRACE("%p\n", socket);
 
-    if (socket->send_q.pool) CloseThreadpool( socket->send_q.pool );
-    if (socket->recv_q.pool) CloseThreadpool( socket->recv_q.pool );
+    stop_queue( &socket->send_q );
+    stop_queue( &socket->recv_q );
 
     release_object( &socket->request->hdr );
     heap_free( socket );
@@ -3526,6 +3534,7 @@ static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *
     struct netconn *netconn = socket->request->netconn;
     DWORD ret;
 
+    stop_queue( &socket->send_q );
     if (!(ret = send_frame( netconn, SOCKET_OPCODE_CLOSE, status, reason, len, TRUE )))
     {
         socket->state = SOCKET_STATE_SHUTDOWN;
@@ -3609,6 +3618,7 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
 
     if (socket->state < SOCKET_STATE_SHUTDOWN)
     {
+        stop_queue( &socket->send_q );
         if ((ret = send_frame( netconn, SOCKET_OPCODE_CLOSE, status, reason, len, TRUE ))) goto done;
         socket->state = SOCKET_STATE_SHUTDOWN;
     }
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index f3ab8c9b959..080837eb1ed 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -578,7 +578,7 @@ static void request_destroy( struct object_header *hdr )
 
     TRACE("%p\n", request);
 
-    if (request->queue.pool) CloseThreadpool( request->queue.pool );
+    stop_queue( &request->queue );
     release_object( &request->connect->hdr );
 
     if (request->cred_handle_initialized) FreeCredentialsHandle( &request->cred_handle );
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 9d0b9c308ab..23aba00780e 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -317,6 +317,7 @@ BOOL free_handle( HINTERNET ) DECLSPEC_HIDDEN;
 
 void send_callback( struct object_header *, DWORD, LPVOID, DWORD ) DECLSPEC_HIDDEN;
 void close_connection( struct request * ) DECLSPEC_HIDDEN;
+void stop_queue( struct queue * ) DECLSPEC_HIDDEN;
 
 void netconn_close( struct netconn * ) DECLSPEC_HIDDEN;
 DWORD netconn_create( struct hostdata *, const struct sockaddr_storage *, int, struct netconn ** ) DECLSPEC_HIDDEN;

From: Owen Rudge <orudge@codeweavers.com>
Subject: [PATCH 1/2] winhttp/tests: Add tests for WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS.
Message-Id: <184c7832-c2a6-7ff2-8333-bd25662597df@codeweavers.com>
Date: Fri, 3 Jul 2020 10:21:37 +0100

Signed-off-by: Owen Rudge <orudge@codeweavers.com>
---
  dlls/winhttp/tests/winhttp.c | 52 ++++++++++++++++++++++++++++++++++++
  1 file changed, 52 insertions(+)

diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index 84063fdc82a..79d700d4a12 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -5076,6 +5076,57 @@ done:
     if (ses) WinHttpCloseHandle( ses );
 }
 
+static void test_max_http_automatic_redirects (void)
+{
+    HINTERNET session, request, connection;
+    DWORD max_redirects, err;
+    BOOL ret;
+
+    session = WinHttpOpen(L"winetest", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
+        WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
+    ok(session != NULL, "WinHttpOpen failed to open session.\n");
+
+    connection = WinHttpConnect (session, L"test.winehq.org", INTERNET_DEFAULT_HTTP_PORT, 0);
+    ok(connection != NULL, "WinHttpConnect failed to open a connection, error: %u.\n", GetLastError());
+
+    /* Test with 2 redirects (page will try to redirect 3 times) */
+    request = WinHttpOpenRequest(connection, L"GET", L"tests/redirecttest.php?max=3", NULL, WINHTTP_NO_REFERER,
+        WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_BYPASS_PROXY_CACHE);
+    if (request == NULL && GetLastError() == ERROR_WINHTTP_NAME_NOT_RESOLVED)
+    {
+        skip("Network unreachable, skipping.\n");
+        goto done;
+    }
+    ok(request != NULL, "WinHttpOpenRequest failed to open a request, error: %u.\n", GetLastError());
+    if (!request) goto done;
+
+    max_redirects = 2;
+    ret = WinHttpSetOption(request, WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS, &max_redirects, sizeof(max_redirects));
+    todo_wine ok(ret, "WinHttpSetOption failed: %u\n", GetLastError());
+
+    ret = WinHttpSendRequest(request, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);
+    err = GetLastError();
+    if (!ret && (err == ERROR_WINHTTP_CANNOT_CONNECT || err == ERROR_WINHTTP_TIMEOUT))
+    {
+        skip("connection failed, skipping\n");
+        goto done;
+    }
+    ok(ret == TRUE, "WinHttpSendRequest failed: %u\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WinHttpReceiveResponse(request, NULL);
+    todo_wine ok(!ret, "WinHttpReceiveResponse succeeded, expected failure\n");
+    todo_wine ok(GetLastError() == ERROR_WINHTTP_REDIRECT_FAILED, "Expected ERROR_WINHTTP_REDIRECT_FAILED, got %u.\n", GetLastError());
+
+ done:
+    ret = WinHttpCloseHandle(request);
+    ok(ret == TRUE, "WinHttpCloseHandle failed on closing request, got %d.\n", ret);
+    ret = WinHttpCloseHandle(connection);
+    ok(ret == TRUE, "WinHttpCloseHandle failed on closing connection, got %d.\n", ret);
+    ret = WinHttpCloseHandle(session);
+    ok(ret == TRUE, "WinHttpCloseHandle failed on closing session, got %d.\n", ret);
+}
+
 START_TEST (winhttp)
 {
     struct server_info si;
@@ -5108,6 +5159,7 @@ START_TEST (winhttp)
     test_WinHttpGetIEProxyConfigForCurrentUser();
     test_WinHttpGetProxyForUrl();
     test_chunked_read();
+    test_max_http_automatic_redirects();
 
     si.event = CreateEventW(NULL, 0, 0, NULL);
     si.port = 7532;

From: Owen Rudge <orudge@codeweavers.com>
Subject: [PATCH 2/2] winhttp: Implement WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS.
Message-Id: <a7511ce1-a6ad-f0b4-f8b6-a719cb518ef9@codeweavers.com>
Date: Fri, 3 Jul 2020 10:21:40 +0100

Signed-off-by: Owen Rudge <orudge@codeweavers.com>
---
  dlls/winhttp/request.c         |  2 ++
  dlls/winhttp/session.c         | 17 +++++++++++++++++
  dlls/winhttp/tests/winhttp.c   |  6 +++---
  dlls/winhttp/winhttp_private.h |  2 ++
  4 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index e31803ccfed..31296cd02ba 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -2720,6 +2720,8 @@ static DWORD receive_response( struct request *request, BOOL async )
             if (request->hdr.disable_flags & WINHTTP_DISABLE_REDIRECTS ||
                 request->hdr.redirect_policy == WINHTTP_OPTION_REDIRECT_POLICY_NEVER) break;
 
+            if (++request->redirect_count > request->max_redirects) return ERROR_WINHTTP_REDIRECT_FAILED;
+
             if ((ret = handle_redirect( request, status ))) break;
 
             /* recurse synchronously */
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index 080837eb1ed..319066db55b 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -820,6 +820,11 @@ static BOOL request_query_option( struct object_header *hdr, DWORD option, void
         str_to_buffer( buffer, request->connect->session->proxy_password, buflen );
         return TRUE;
 
+    case WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS:
+        *(DWORD *)buffer = request->max_redirects;
+        *buflen = sizeof(DWORD);
+        return TRUE;
+
     default:
         FIXME("unimplemented option %u\n", option);
         SetLastError( ERROR_INVALID_PARAMETER );
@@ -1028,6 +1033,17 @@ static BOOL request_set_option( struct object_header *hdr, DWORD option, void *b
         FIXME("WINHTTP_OPTION_CONNECT_RETRIES\n");
         return TRUE;
 
+    case WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS:
+        if (buflen == sizeof(DWORD))
+        {
+            request->max_redirects = *(DWORD *)buffer;
+            SetLastError(NO_ERROR);
+            return TRUE;
+        }
+
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+
     default:
         FIXME("unimplemented option %u\n", option);
         SetLastError( ERROR_WINHTTP_INVALID_OPTION );
@@ -1121,6 +1137,7 @@ HINTERNET WINAPI WinHttpOpenRequest( HINTERNET hconnect, LPCWSTR verb, LPCWSTR o
     request->send_timeout = connect->session->send_timeout;
     request->receive_timeout = connect->session->receive_timeout;
     request->receive_response_timeout = connect->session->receive_response_timeout;
+    request->max_redirects = 10;
 
     if (!verb || !verb[0]) verb = L"GET";
     if (!(request->verb = strdupW( verb ))) goto end;
diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index 79d700d4a12..5379640d5fc 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -5102,7 +5102,7 @@ static void test_max_http_automatic_redirects (void)
 
     max_redirects = 2;
     ret = WinHttpSetOption(request, WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS, &max_redirects, sizeof(max_redirects));
-    todo_wine ok(ret, "WinHttpSetOption failed: %u\n", GetLastError());
+    ok(ret, "WinHttpSetOption failed: %u\n", GetLastError());
 
     ret = WinHttpSendRequest(request, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);
     err = GetLastError();
@@ -5115,8 +5115,8 @@ static void test_max_http_automatic_redirects (void)
 
     SetLastError(0xdeadbeef);
     ret = WinHttpReceiveResponse(request, NULL);
-    todo_wine ok(!ret, "WinHttpReceiveResponse succeeded, expected failure\n");
-    todo_wine ok(GetLastError() == ERROR_WINHTTP_REDIRECT_FAILED, "Expected ERROR_WINHTTP_REDIRECT_FAILED, got %u.\n", GetLastError());
+    ok(!ret, "WinHttpReceiveResponse succeeded, expected failure\n");
+    ok(GetLastError() == ERROR_WINHTTP_REDIRECT_FAILED, "Expected ERROR_WINHTTP_REDIRECT_FAILED, got %u.\n", GetLastError());
 
  done:
     ret = WinHttpCloseHandle(request);
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 23aba00780e..e279e58a5fe 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -189,6 +189,8 @@ struct request
     int send_timeout;
     int receive_timeout;
     int receive_response_timeout;
+    DWORD max_redirects;
+    DWORD redirect_count; /* total number of redirects during this request */
     WCHAR *status_text;
     DWORD content_length; /* total number of bytes to be read */
     DWORD content_read;   /* bytes read so far */

From: Serge Gautherie <winehq-git_serge_180711@gautherie.fr>
Subject: [PATCH] wininet: Increase user size to 'UNLEN + 1' in create_cookie_url().
Message-Id: <20200701143418.2768-1-winehq-git_serge_180711@gautherie.fr>
Date: Wed,  1 Jul 2020 16:34:18 +0200

Signed-off-by: Serge Gautherie <winehq-git_serge_180711@gautherie.fr>
---
 dlls/wininet/cookie.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/wininet/cookie.c b/dlls/wininet/cookie.c
index b5f779b..4d0967b 100644
--- a/dlls/wininet/cookie.c
+++ b/dlls/wininet/cookie.c
@@ -147,7 +147,7 @@ static cookie_domain_t *get_cookie_domain(substr_t domain, BOOL create)
 
 static WCHAR *create_cookie_url(substr_t domain, substr_t path, substr_t *ret_path)
 {
-    WCHAR user[UNLEN], *p, *url;
+    WCHAR user[UNLEN + 1], *p, *url;
     DWORD len, user_len, i;
 
     static const WCHAR cookie_prefix[] = {'C','o','o','k','i','e',':'};

-- 
2.10.0.windows.1

